<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>rcatool.stats.convolve &mdash; RCAT 0.1 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="../../../_static/css/theme.css?v=19f00094" />

  
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../../_static/jquery.js?v=5d32c60e"></script>
        <script src="../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="../../../_static/documentation_options.js?v=2709fde1"></script>
        <script src="../../../_static/doctools.js?v=9a2dae69"></script>
        <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../index.html" class="icon icon-home">
            RCAT
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorials.html">Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../howto.html">How-To Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../development.html">Development</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api.html">API-reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../release.html">Release notes</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">RCAT</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">rcatool.stats.convolve</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for rcatool.stats.convolve</h1><div class="highlight"><pre>
<span></span><span class="ch">#!/usr/bin/env python</span>
<span class="c1">#</span>
<span class="c1">#</span>
<span class="c1"># Functions for convolution of arrays ##</span>
<span class="c1">#</span>
<span class="c1"># By: Petter Lind</span>
<span class="c1">#     2014-04-11</span>
<span class="c1">#</span>
<span class="c1">#</span>
<span class="c1">#</span>

<span class="c1"># Import necessary modules</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">signal</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">This module includes functions to perform convolution, for example</span>
<span class="sd">image smoothing, partly using scipy&#39;s convolution routines.</span>
<span class="sd">&quot;&quot;&quot;</span>


<div class="viewcode-block" id="kernel_gen">
<a class="viewcode-back" href="../../../rcatool.stats.html#rcatool.stats.convolve.kernel_gen">[docs]</a>
<span class="k">def</span> <span class="nf">kernel_gen</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">ktype</span><span class="o">=</span><span class="s1">&#39;square&#39;</span><span class="p">,</span> <span class="n">kfun</span><span class="o">=</span><span class="s1">&#39;mean&#39;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Function to create a kernel, i.e. a moving window (box or disk) with</span>
<span class="sd">    side/radius equal to &#39;n&#39;.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    n: int</span>
<span class="sd">        Side/radius of square/disk of smoothening window.</span>
<span class="sd">    ktype: string</span>
<span class="sd">        The type of box; &#39;square&#39; (default) or &#39;disk&#39;.</span>
<span class="sd">    kfun: string</span>
<span class="sd">        The function &#39;kfun&#39; applied to each sub-sample within the moving</span>
<span class="sd">        window. Either &#39;mean&#39; (default) or &#39;sum&#39;.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">ktype</span> <span class="o">==</span> <span class="s1">&#39;square&#39;</span><span class="p">):</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">kfun</span> <span class="o">==</span> <span class="s1">&#39;mean&#39;</span><span class="p">):</span>
            <span class="n">kernel</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.</span><span class="o">/</span><span class="n">n</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">kfun</span> <span class="o">==</span> <span class="s1">&#39;sum&#39;</span><span class="p">):</span>
            <span class="n">kernel</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span>
    <span class="k">elif</span> <span class="p">(</span><span class="n">ktype</span> <span class="o">==</span> <span class="s1">&#39;disk&#39;</span><span class="p">):</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">kfun</span> <span class="o">==</span> <span class="s1">&#39;mean&#39;</span><span class="p">):</span>
            <span class="n">y</span><span class="p">,</span> <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ogrid</span><span class="p">[</span><span class="o">-</span><span class="n">n</span><span class="p">:</span> <span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="n">n</span><span class="p">:</span> <span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">disk</span> <span class="o">=</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">y</span><span class="o">**</span><span class="mi">2</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="o">**</span><span class="mi">2</span>
            <span class="n">disk</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">disk</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>
            <span class="n">kernel</span> <span class="o">=</span> <span class="n">disk</span><span class="o">/</span><span class="n">n</span><span class="o">**</span><span class="mi">2</span>

    <span class="k">return</span> <span class="n">kernel</span></div>



<div class="viewcode-block" id="filtering">
<a class="viewcode-back" href="../../../rcatool.stats.html#rcatool.stats.convolve.filtering">[docs]</a>
<span class="k">def</span> <span class="nf">filtering</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">wgts</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;valid&#39;</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fft</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
              <span class="n">fftn</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftn</span><span class="p">,</span> <span class="n">ifftn</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">ifftn</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    1D and 2D filtering procedures.</span>

<span class="sd">    Filters input data, both 1D and 2D, with user defined weights. Set fft to</span>
<span class="sd">    True for fast fourier transform to speed things up when data is large.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data: array</span>
<span class="sd">        Data to be filtered.</span>
<span class="sd">    wgts: array/list</span>
<span class="sd">        The weights (kernel) to be used in the filtering.</span>
<span class="sd">    mode: str</span>
<span class="sd">        String indicating the size of output (see</span>
<span class="sd">        https://docs.scipy.org/doc/scipy/reference/signal.html)</span>
<span class="sd">    dim: int</span>
<span class="sd">        If 1 one-dimensional filtering is performed and if &#39;axis&#39; is also set,</span>
<span class="sd">        1D-filtering is applied along this axis. If dim=2 two-dimensional</span>
<span class="sd">        filtering is applied.</span>
<span class="sd">    fft: boolean</span>
<span class="sd">        Set True to use fast fourier transform in the 2D filtering.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    data_conv: array</span>
<span class="sd">        Convoluted data</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">MaskedArray</span><span class="p">):</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">mask</span>    <span class="c1"># Set masked values to zero</span>
        <span class="n">indata</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">filled</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">indata</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">dim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="c1"># One-dimensional filtering</span>
        <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">data_conv</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">convolve</span><span class="p">(</span><span class="n">indata</span><span class="p">,</span> <span class="n">wgts</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">data_conv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">apply_along_axis</span><span class="p">(</span><span class="n">signal</span><span class="o">.</span><span class="n">convolve</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">indata</span><span class="p">,</span>
                                            <span class="n">wgts</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">dim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="c1"># Two-dimensional filtering</span>
        <span class="k">if</span> <span class="n">fft</span><span class="p">:</span>
            <span class="n">data_conv</span> <span class="o">=</span> <span class="n">convolve_fft</span><span class="p">(</span><span class="n">indata</span><span class="p">,</span> <span class="n">wgts</span><span class="p">,</span> <span class="n">fftn</span><span class="o">=</span><span class="n">fftn</span><span class="p">,</span> <span class="n">ifftn</span><span class="o">=</span><span class="n">ifftn</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">data_conv</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">convolve2d</span><span class="p">(</span><span class="n">indata</span><span class="p">,</span> <span class="n">wgts</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span>
                                          <span class="n">boundary</span><span class="o">=</span><span class="s1">&#39;symm&#39;</span><span class="p">)</span>

    <span class="c1"># Set values in mask to NaN (if masked array)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">MaskedArray</span><span class="p">):</span>
        <span class="n">data_conv</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

    <span class="k">return</span> <span class="n">data_conv</span></div>



<div class="viewcode-block" id="lanczos_filter">
<a class="viewcode-back" href="../../../rcatool.stats.html#rcatool.stats.convolve.lanczos_filter">[docs]</a>
<span class="k">def</span> <span class="nf">lanczos_filter</span><span class="p">(</span><span class="n">window</span><span class="p">,</span> <span class="n">cutoff</span><span class="p">,</span> <span class="n">cutoff_2</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ftype</span><span class="o">=</span><span class="s1">&#39;lowpass&#39;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate weights for a low pass Lanczos filter.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    window: int</span>
<span class="sd">        The length of the filter window.</span>

<span class="sd">    cutoff: float</span>
<span class="sd">        The cutoff frequency in inverse time steps.</span>
<span class="sd">    cutoff_2: float</span>
<span class="sd">        The second cutoff frequency in inverse time steps. Only used if ftype</span>
<span class="sd">        is &#39;bandpass&#39;</span>
<span class="sd">    ftype: str</span>
<span class="sd">        The type of cutoff filtering: &#39;lowpass&#39;, &#39;highpass&#39; or &#39;bandpass&#39;.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    wgts: vector</span>
<span class="sd">        Array with calculated weights.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">_low_pass_filter</span><span class="p">(</span><span class="n">win</span><span class="p">,</span> <span class="n">cut</span><span class="p">):</span>
        <span class="n">order</span> <span class="o">=</span> <span class="p">((</span><span class="n">win</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">nwts</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">order</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">nwts</span><span class="p">])</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">nwts</span> <span class="o">//</span> <span class="mi">2</span>
        <span class="n">w</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">cut</span>
        <span class="n">k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">1.</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
        <span class="n">sigma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">k</span> <span class="o">/</span> <span class="n">n</span><span class="p">)</span> <span class="o">*</span> <span class="n">n</span> <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">k</span><span class="p">)</span>
        <span class="n">firstfactor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mf">2.</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">cut</span> <span class="o">*</span> <span class="n">k</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">k</span><span class="p">)</span>
        <span class="n">w</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">firstfactor</span> <span class="o">*</span> <span class="n">sigma</span>
        <span class="n">w</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">firstfactor</span> <span class="o">*</span> <span class="n">sigma</span>
        <span class="k">return</span> <span class="n">w</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">ftype</span> <span class="o">==</span> <span class="s1">&#39;lowpass&#39;</span><span class="p">:</span>
        <span class="n">wgts_out</span> <span class="o">=</span> <span class="n">_low_pass_filter</span><span class="p">(</span><span class="n">window</span><span class="p">,</span> <span class="n">cutoff</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">ftype</span> <span class="o">==</span> <span class="s1">&#39;highpass&#39;</span><span class="p">:</span>
        <span class="n">wgts_out</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">_low_pass_filter</span><span class="p">(</span><span class="n">window</span><span class="p">,</span> <span class="n">cutoff</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">ftype</span> <span class="o">==</span> <span class="s1">&#39;bandpass&#39;</span><span class="p">:</span>
        <span class="k">assert</span> <span class="n">cutoff_2</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;cutoff_2 must be set for ftype bandpass&quot;</span>
        <span class="n">wgts1</span> <span class="o">=</span> <span class="n">_low_pass_filter</span><span class="p">(</span><span class="n">window</span><span class="p">,</span> <span class="n">cutoff</span><span class="p">)</span>
        <span class="n">wgts2</span> <span class="o">=</span> <span class="n">_low_pass_filter</span><span class="p">(</span><span class="n">window</span><span class="p">,</span> <span class="n">cutoff_2</span><span class="p">)</span>
        <span class="n">wgts_out</span> <span class="o">=</span> <span class="n">wgts2</span> <span class="o">-</span> <span class="n">wgts1</span>

    <span class="k">return</span> <span class="n">wgts_out</span></div>



<div class="viewcode-block" id="fft_prep">
<a class="viewcode-back" href="../../../rcatool.stats.html#rcatool.stats.convolve.fft_prep">[docs]</a>
<span class="k">def</span> <span class="nf">fft_prep</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">kernel</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">,</span> <span class="n">boundary</span><span class="o">=</span><span class="s1">&#39;fill&#39;</span><span class="p">,</span> <span class="n">psf_pad</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
             <span class="n">fft_pad</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Prepare data array and kernel for fft computation.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    boundary : {&#39;fill&#39;, &#39;wrap&#39;}, optional</span>
<span class="sd">        A flag indicating how to handle boundaries:</span>

<span class="sd">            * &#39;fill&#39;: set values outside the array boundary to fill_value</span>
<span class="sd">              (default)</span>
<span class="sd">            * &#39;wrap&#39;: periodic boundary</span>
<span class="sd">    fft_pad : bool, optional</span>
<span class="sd">        Default on.  Zero-pad image to the nearest 2^n</span>
<span class="sd">    psf_pad : bool, optional</span>
<span class="sd">        Default off.  Zero-pad image to be at least the sum of the image sizes</span>
<span class="sd">        (in order to avoid edge-wrapping when smoothing)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">arrayshape</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">kernshape</span> <span class="o">=</span> <span class="n">kernel</span><span class="o">.</span><span class="n">shape</span>

    <span class="c1"># mask catching - masks must be turned into NaNs for use later</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">is_masked</span><span class="p">(</span><span class="n">array</span><span class="p">):</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">mask</span>
        <span class="n">array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">array</span><span class="p">)</span>
        <span class="n">array</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">is_masked</span><span class="p">(</span><span class="n">kernel</span><span class="p">):</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">kernel</span><span class="o">.</span><span class="n">mask</span>
        <span class="n">kernel</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">kernel</span><span class="p">)</span>
        <span class="n">kernel</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

    <span class="c1"># NaN and inf catching</span>
    <span class="n">nanmaskarray</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">array</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">array</span><span class="p">)</span>
    <span class="n">array</span><span class="p">[</span><span class="n">nanmaskarray</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">nanmaskkernel</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">kernel</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">kernel</span><span class="p">)</span>
    <span class="n">kernel</span><span class="p">[</span><span class="n">nanmaskkernel</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">if</span> <span class="n">boundary</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">psf_pad</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">elif</span> <span class="n">boundary</span> <span class="o">==</span> <span class="s1">&#39;fill&#39;</span><span class="p">:</span>
        <span class="c1"># create a boundary region at least as large as the kernel</span>
        <span class="n">psf_pad</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">elif</span> <span class="n">boundary</span> <span class="o">==</span> <span class="s1">&#39;wrap&#39;</span><span class="p">:</span>
        <span class="n">psf_pad</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">fft_pad</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">fill_value</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># force zero; it should not be used</span>
    <span class="k">elif</span> <span class="n">boundary</span> <span class="o">==</span> <span class="s1">&#39;extend&#39;</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;The &#39;extend&#39; option is not implemented &quot;</span>
                                  <span class="s2">&quot;for fft-based convolution&quot;</span><span class="p">)</span>

    <span class="c1"># find ideal size (power of 2) for fft.</span>
    <span class="c1"># Can add shapes because they are tuples</span>
    <span class="k">if</span> <span class="n">fft_pad</span><span class="p">:</span>         <span class="c1"># default=True</span>
        <span class="k">if</span> <span class="n">psf_pad</span><span class="p">:</span>     <span class="c1"># default=False</span>
            <span class="c1"># add the dimensions and then take the max (bigger)</span>
            <span class="n">fsize</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">**</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">arrayshape</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">kernshape</span><span class="p">))))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># add the shape lists (max of a list of length 4) (smaller)</span>
            <span class="c1"># also makes the shapes square</span>
            <span class="n">fsize</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">**</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">arrayshape</span> <span class="o">+</span> <span class="n">kernshape</span><span class="p">)))</span>
        <span class="n">newshape</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">fsize</span> <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">array</span><span class="o">.</span><span class="n">ndim</span><span class="p">)],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">psf_pad</span><span class="p">:</span>
            <span class="c1"># just add the biggest dimensions</span>
            <span class="n">newshape</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">arrayshape</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">kernshape</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">newshape</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">([</span><span class="n">imsh</span><span class="p">,</span> <span class="n">kernsh</span><span class="p">])</span>
                                <span class="k">for</span> <span class="n">imsh</span><span class="p">,</span> <span class="n">kernsh</span>
                                <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">arrayshape</span><span class="p">,</span> <span class="n">kernshape</span><span class="p">)])</span>

    <span class="c1"># separate each dimension by the padding size...  this is to determine the</span>
    <span class="c1"># appropriate slice size to get back to the input dimensions</span>
    <span class="n">arrayslices</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">kernslices</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="p">(</span><span class="n">newdimsize</span><span class="p">,</span> <span class="n">arraydimsize</span><span class="p">,</span> <span class="n">kerndimsize</span><span class="p">)</span>\
            <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">newshape</span><span class="p">,</span> <span class="n">arrayshape</span><span class="p">,</span> <span class="n">kernshape</span><span class="p">)):</span>
        <span class="n">center</span> <span class="o">=</span> <span class="n">newdimsize</span> <span class="o">-</span> <span class="p">(</span><span class="n">newdimsize</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
        <span class="n">arrayslices</span> <span class="o">+=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="n">center</span> <span class="o">-</span> <span class="n">arraydimsize</span> <span class="o">//</span> <span class="mi">2</span><span class="p">,</span>
                              <span class="n">center</span> <span class="o">+</span> <span class="p">(</span><span class="n">arraydimsize</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)]</span>
        <span class="n">kernslices</span> <span class="o">+=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="n">center</span> <span class="o">-</span> <span class="n">kerndimsize</span> <span class="o">//</span> <span class="mi">2</span><span class="p">,</span>
                             <span class="n">center</span> <span class="o">+</span> <span class="p">(</span><span class="n">kerndimsize</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)]</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">newshape</span> <span class="o">==</span> <span class="n">arrayshape</span><span class="p">):</span>
        <span class="n">bigarray</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">newshape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex</span><span class="p">)</span> <span class="o">*</span> <span class="n">fill_value</span>
        <span class="n">bigarray</span><span class="p">[</span><span class="n">arrayslices</span><span class="p">]</span> <span class="o">=</span> <span class="n">array</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">bigarray</span> <span class="o">=</span> <span class="n">array</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">newshape</span> <span class="o">==</span> <span class="n">kernshape</span><span class="p">):</span>
        <span class="n">bigkernel</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">newshape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex</span><span class="p">)</span>
        <span class="n">bigkernel</span><span class="p">[</span><span class="n">kernslices</span><span class="p">]</span> <span class="o">=</span> <span class="n">kernel</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">bigkernel</span> <span class="o">=</span> <span class="n">kernel</span>

    <span class="k">return</span> <span class="n">bigarray</span><span class="p">,</span> <span class="n">bigkernel</span><span class="p">,</span> <span class="n">arrayslices</span><span class="p">,</span>\
        <span class="n">kernslices</span><span class="p">,</span> <span class="n">newshape</span><span class="p">,</span> <span class="n">nanmaskarray</span><span class="p">,</span> <span class="n">nanmaskkernel</span></div>



<div class="viewcode-block" id="convolve_fft">
<a class="viewcode-back" href="../../../rcatool.stats.html#rcatool.stats.convolve.convolve_fft">[docs]</a>
<span class="k">def</span> <span class="nf">convolve_fft</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">kernel</span><span class="p">,</span> <span class="n">boundary</span><span class="o">=</span><span class="s1">&#39;fill&#39;</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">crop</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                 <span class="n">return_fft</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">fft_pad</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">psf_pad</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                 <span class="n">interpolate_nan</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">quiet</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">ignore_edge_zeros</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                 <span class="n">min_wt</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">normalize_kernel</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">allow_huge</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                 <span class="n">fftn</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftn</span><span class="p">,</span> <span class="n">ifftn</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">ifftn</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convolve an ndarray with an nd-kernel.  Returns a convolved image with</span>
<span class="sd">    shape = array.shape.  Assumes kernel is centered.</span>

<span class="sd">    `convolve_fft` differs from `scipy.signal.fftconvolve` in a few ways:</span>

<span class="sd">    * It can treat ``NaN`` values as zeros or interpolate over them.</span>
<span class="sd">    * ``inf`` values are treated as ``NaN``</span>
<span class="sd">    * (optionally) It pads to the nearest 2^n size to improve FFT speed.</span>
<span class="sd">    * Its only valid ``mode`` is &#39;same&#39; (i.e. the same shape array is returned)</span>
<span class="sd">    * It lets you use your own fft, e.g.,</span>
<span class="sd">      `pyFFTW &lt;http://pypi.python.org/pypi/pyFFTW&gt;` or</span>
<span class="sd">      `pyFFTW3 &lt;http://pypi.python.org/pypi/PyFFTW3/0.2.1&gt;`,</span>
<span class="sd">      which can lead to performance improvements, depending on your system</span>
<span class="sd">      configuration. pyFFTW3 is threaded, and therefore may yield significant</span>
<span class="sd">      performance benefits on multi-core machines at the cost of greater</span>
<span class="sd">      memory requirements. Specify the ``fftn`` and ``ifftn`` keywords to</span>
<span class="sd">      override the default, which is `numpy.fft.fft` and `numpy.fft.ifft`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    array : `numpy.ndarray`</span>
<span class="sd">        Array to be convolved with ``kernel``</span>
<span class="sd">    kernel : `numpy.ndarray`</span>
<span class="sd">        Will be normalized if ``normalize_kernel`` is set.  Assumed to be</span>
<span class="sd">        centered (i.e., shifts may result if your kernel is asymmetric)</span>
<span class="sd">    boundary : {&#39;fill&#39;, &#39;wrap&#39;}, optional</span>
<span class="sd">        A flag indicating how to handle boundaries:</span>
<span class="sd">        * &#39;fill&#39;: set values outside the array boundary to fill_value (default)</span>
<span class="sd">        * &#39;wrap&#39;: periodic boundary</span>

<span class="sd">    interpolate_nan : bool, optional</span>
<span class="sd">        The convolution will be re-weighted assuming ``NaN`` values are meant</span>
<span class="sd">        to be ignored, not treated as zero.  If this is off, all ``NaN`` values</span>
<span class="sd">        will be treated as zero.</span>
<span class="sd">    ignore_edge_zeros : bool, optional</span>
<span class="sd">        Ignore the zero-pad-created zeros.</span>
<span class="sd">        This will effectively decrease the kernel area on the edges but will</span>
<span class="sd">        not re-normalize the kernel. This parameter may result in</span>
<span class="sd">        &#39;edge-brightening&#39; effects if you&#39;re using a normalized kernel</span>
<span class="sd">    min_wt : float, optional</span>
<span class="sd">        If ignoring ``NaN`` / zeros, force all grid points with a weight less</span>
<span class="sd">        than this value to ``NaN`` (the weight of a grid point with *no*</span>
<span class="sd">        ignored neighbors is 1.0). If ``min_wt`` is zero, then all zero-weight</span>
<span class="sd">        points will be set to zero instead of ``NaN`` (which they would be</span>
<span class="sd">        otherwise, because 1/0 = nan). See the examples below</span>
<span class="sd">    normalize_kernel : function or boolean, optional</span>
<span class="sd">        If specified, this is the function to divide kernel by to normalize it.</span>
<span class="sd">        e.g., ``normalize_kernel=np.sum`` means that kernel will be modified</span>
<span class="sd">        to be:</span>
<span class="sd">        ``kernel = kernel / np.sum(kernel)``.  If True, defaults to</span>
<span class="sd">        ``normalize_kernel = np.sum``.</span>

<span class="sd">    Other Parameters</span>
<span class="sd">    ----------------</span>
<span class="sd">    fft_pad : bool, optional</span>
<span class="sd">        Default on.  Zero-pad image to the nearest 2^n</span>
<span class="sd">    psf_pad : bool, optional</span>
<span class="sd">        Default off.  Zero-pad image to be at least the sum of the image sizes</span>
<span class="sd">        (in order to avoid edge-wrapping when smoothing)</span>
<span class="sd">    crop : bool, optional</span>
<span class="sd">        Default on.  Return an image of the size of the largest input image.</span>
<span class="sd">        If the images are asymmetric in opposite directions, will return the</span>
<span class="sd">        largest image in both directions.</span>
<span class="sd">        For example, if an input image has shape [100,3] but a kernel with</span>
<span class="sd">        shape [6,6] is used, the output will be [100,6].</span>
<span class="sd">    return_fft : bool, optional</span>
<span class="sd">        Return the fft(image)*fft(kernel) instead of the convolution (which is</span>
<span class="sd">        ifft(fft(image)*fft(kernel))).  Useful for making PSDs.</span>
<span class="sd">    fftn, ifftn : functions, optional</span>
<span class="sd">        The fft and inverse fft functions.  Can be overridden to use your own</span>
<span class="sd">        ffts, e.g. an fftw3 wrapper or scipy&#39;s fftn, e.g.</span>
<span class="sd">        ``fftn=scipy.fftpack.fftn``</span>
<span class="sd">    complex_dtype : np.complex, optional</span>
<span class="sd">        Which complex dtype to use.  `numpy` has a range of options, from 64 to</span>
<span class="sd">        256.</span>
<span class="sd">    quiet : bool, optional</span>
<span class="sd">        Silence warning message about NaN interpolation</span>
<span class="sd">    allow_huge : bool, optional</span>
<span class="sd">        Allow huge arrays in the FFT?  If False, will raise an exception if the</span>
<span class="sd">        array or kernel size is &gt;1 GB</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ValueError:</span>
<span class="sd">        If the array is bigger than 1 GB after padding, will raise this</span>
<span class="sd">        exception unless allow_huge is True</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    convolve : Convolve is a non-fft version of this code.  It is more</span>
<span class="sd">               memory efficient and for small kernels can be faster.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    default : ndarray</span>
<span class="sd">        **array** convolved with ``kernel``.</span>
<span class="sd">        If ``return_fft`` is set, returns fft(**array**) * fft(``kernel``).</span>
<span class="sd">        If crop is not set, returns the image, but with the fft-padded size</span>
<span class="sd">        instead of the input size</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex</span><span class="p">)</span>
    <span class="n">kernel</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">kernel</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex</span><span class="p">)</span>

    <span class="c1"># Check that the number of dimensions is compatible</span>
    <span class="k">if</span> <span class="n">array</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="n">kernel</span><span class="o">.</span><span class="n">ndim</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Image and kernel must have same number of &quot;</span>
                         <span class="s2">&quot;dimensions&quot;</span><span class="p">)</span>

    <span class="n">arrayshape</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">shape</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">allow_huge</span><span class="p">:</span>
        <span class="n">array_size_B</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">arrayshape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span> <span class="o">*</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">complex</span><span class="p">)</span><span class="o">.</span><span class="n">itemsize</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">array_size_B</span> <span class="o">&gt;</span> <span class="mi">1024</span><span class="o">**</span><span class="mi">3</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Size Error: Use allow_huge=True to override</span><span class="se">\</span>
<span class="s2">                             this exception.&quot;</span><span class="p">)</span>

    <span class="n">bigarray</span><span class="p">,</span> <span class="n">bigkernel</span><span class="p">,</span> <span class="n">arrayslices</span><span class="p">,</span> <span class="n">kernslices</span><span class="p">,</span>\
        <span class="n">newshape</span><span class="p">,</span> <span class="n">nanmaskarray</span><span class="p">,</span> <span class="n">nanmaskkernel</span> <span class="o">=</span>\
        <span class="n">fft_prep</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">kernel</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">,</span> <span class="n">boundary</span><span class="o">=</span><span class="s1">&#39;fill&#39;</span><span class="p">,</span>
                 <span class="n">psf_pad</span><span class="o">=</span><span class="n">psf_pad</span><span class="p">,</span> <span class="n">fft_pad</span><span class="o">=</span><span class="n">fft_pad</span><span class="p">)</span>

    <span class="n">arrayfft</span> <span class="o">=</span> <span class="n">fftn</span><span class="p">(</span><span class="n">bigarray</span><span class="p">)</span>
    <span class="c1"># need to shift the kernel so that, e.g., [0,0,1,0] -&gt; [1,0,0,0] = unity</span>
    <span class="n">kernfft</span> <span class="o">=</span> <span class="n">fftn</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">ifftshift</span><span class="p">(</span><span class="n">bigkernel</span><span class="p">))</span>
    <span class="n">fftmult</span> <span class="o">=</span> <span class="n">arrayfft</span> <span class="o">*</span> <span class="n">kernfft</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">interpolate_nan</span> <span class="ow">or</span> <span class="n">ignore_edge_zeros</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">ignore_edge_zeros</span><span class="p">:</span>
            <span class="n">bigimwt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">newshape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">bigimwt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">newshape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex</span><span class="p">)</span>
        <span class="n">bigimwt</span><span class="p">[</span><span class="n">arrayslices</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">nanmaskarray</span> <span class="o">*</span> <span class="n">interpolate_nan</span>
        <span class="n">wtfft</span> <span class="o">=</span> <span class="n">fftn</span><span class="p">(</span><span class="n">bigimwt</span><span class="p">)</span>
        <span class="c1"># I think this one HAS to be normalized (i.e., the weights can&#39;t be</span>
        <span class="c1"># computed with a non-normalized kernel)</span>
        <span class="n">wtfftmult</span> <span class="o">=</span> <span class="n">wtfft</span> <span class="o">*</span> <span class="n">kernfft</span> <span class="o">/</span> <span class="n">kernel</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="n">wtsm</span> <span class="o">=</span> <span class="n">ifftn</span><span class="p">(</span><span class="n">wtfftmult</span><span class="p">)</span>

        <span class="c1"># need to re-zero weights outside of the image (if it is padded, we</span>
        <span class="c1"># still don&#39;t weight those regions)</span>
        <span class="n">bigimwt</span><span class="p">[</span><span class="n">arrayslices</span><span class="p">]</span> <span class="o">=</span> <span class="n">wtsm</span><span class="o">.</span><span class="n">real</span><span class="p">[</span><span class="n">arrayslices</span><span class="p">]</span>
        <span class="c1"># curiously, at the floating-point limit, can get slightly negative</span>
        <span class="c1"># numbers they break the min_wt=0 &quot;flag&quot; and must therefore be removed</span>
        <span class="n">bigimwt</span><span class="p">[</span><span class="n">bigimwt</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">bigimwt</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">fftmult</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
        <span class="c1"># this check should be unnecessary; call it an insanity check</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Encountered NaNs in convolve.  This is disallowed.&quot;</span><span class="p">)</span>

    <span class="c1"># restore NaNs in original image (they were modified inplace earlier)</span>
    <span class="c1"># We don&#39;t have to worry about masked arrays - if input was masked, it was</span>
    <span class="c1"># copied</span>
    <span class="n">array</span><span class="p">[</span><span class="n">nanmaskarray</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    <span class="n">kernel</span><span class="p">[</span><span class="n">nanmaskkernel</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

    <span class="k">if</span> <span class="n">return_fft</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">fftmult</span>

    <span class="k">if</span> <span class="n">interpolate_nan</span> <span class="ow">or</span> <span class="n">ignore_edge_zeros</span><span class="p">:</span>
        <span class="n">rifft</span> <span class="o">=</span> <span class="p">(</span><span class="n">ifftn</span><span class="p">(</span><span class="n">fftmult</span><span class="p">))</span> <span class="o">/</span> <span class="n">bigimwt</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">bigimwt</span><span class="p">):</span>
            <span class="n">rifft</span><span class="p">[</span><span class="n">bigimwt</span> <span class="o">&lt;</span> <span class="n">min_wt</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="k">if</span> <span class="n">min_wt</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">:</span>
                <span class="n">rifft</span><span class="p">[</span><span class="n">bigimwt</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">rifft</span> <span class="o">=</span> <span class="p">(</span><span class="n">ifftn</span><span class="p">(</span><span class="n">fftmult</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">crop</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">rifft</span><span class="p">[</span><span class="n">arrayslices</span><span class="p">]</span><span class="o">.</span><span class="n">real</span>
        <span class="k">return</span> <span class="n">result</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">rifft</span><span class="o">.</span><span class="n">real</span></div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2024, Petter Lind.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>